<!doctype html>
<html lang="zh">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D 卡丁车（CDN容错版）</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0b0e12;color:#e8f0f7;
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans SC","PingFang SC","Hiragino Sans GB",Arial,sans-serif}
  #hud{position:fixed;left:12px;top:12px;padding:10px 12px;border-radius:12px;background:rgba(0,0,0,.35);backdrop-filter:blur(4px);font-size:14px}
  #err{position:fixed;left:12px;bottom:12px;max-width:min(92vw,640px);background:#271317;border:1px solid #6c2a36;color:#ffd9de;
    padding:10px 12px;border-radius:10px;display:none;white-space:pre-wrap}
  #help{position:fixed;right:12px;top:12px;padding:10px 12px;border-radius:12px;background:rgba(0,0,0,.35)}
  .tag{display:inline-block;border:1px solid #2a3b5c;border-radius:999px;padding:2px 8px;margin-left:6px;font-size:12px;color:#9bd6ff}
</style>
<body>
<div id="hud">速度 <span id="v">0</span> m/s<br>圈数 <span id="lap">0</span><span class="tag">起点=白线</span><br>本圈 <span id="lapTime">0.00</span>s　最佳 <span id="best">—</span></div>
<div id="help">W/S 加速刹车　A/D 转向　空格手刹　R 重置　P 暂停</div>
<div id="err"></div>

<script type="module">
const errBox = document.getElementById('err');
async function loadThree() {
  const bases = [
    'https://cdn.jsdelivr.net/npm/three@0.160.0',
    'https://unpkg.com/three@0.160.0',
    'https://esm.sh/three@0.160.0'
  ];
  const logs = [];
  for (const base of bases) {
    try {
      const THREE = await import(base + '/build/three.module.js');
      const { OrbitControls } = await import(base + '/examples/jsm/controls/OrbitControls.js');
      return { THREE, OrbitControls, used: base };
    } catch(e) {
      logs.push(`CDN 失败：${base}\n${e.message || e}`);
    }
  }
  throw new Error('所有 CDN 加载失败。\n\n' + logs.join('\n\n'));
}

function showError(msg){
  errBox.style.display='block';
  errBox.textContent = '加载出错：\n' + msg + '\n\n建议：\n1) 刷新试试（Ctrl+F5）\n2) 换网络/开全局代理\n3) 稍后再试';
}

let THREE, OrbitControls;
let scene, camera, renderer, car, walls, bar;
let vel=0, sideVel=0, steer=0, paused=false;
const keys={};
addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='KeyP') paused=!paused; if(e.code==='KeyR') resetCar(); });
addEventListener('keyup',   e=>{ keys[e.code]=false; });

function resetCar(){
  car.position.set(0,0.6,-105);
  vel=0; sideVel=0; steer=0; car.rotation.y=0;
}

function setup(usedCdn){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x10141b);

  scene.add(new THREE.HemisphereLight(0x91a7ff, 0x1b2a1f, 0.8));
  const sun = new THREE.DirectionalLight(0xffffff, 0.9);
  sun.position.set(100,120,80); sun.castShadow = true; scene.add(sun);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000),
    new THREE.MeshStandardMaterial({color:0x1a222a}));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  const track = new THREE.Mesh(
    new THREE.RingGeometry(70,120,64,1,0,Math.PI*2),
    new THREE.MeshStandardMaterial({color:0x2a343f, side:THREE.DoubleSide})
  );
  track.rotation.x = -Math.PI/2; scene.add(track);

  const startLine = new THREE.Mesh(new THREE.BoxGeometry(4,0.2,16),
    new THREE.MeshStandardMaterial({color:0xffffff}));
  startLine.position.set(0,0.11,-95); scene.add(startLine);

  walls = new THREE.Group();
  function addWall(x,z,w,d,rot=0){
    const m = new THREE.Mesh(new THREE.BoxGeometry(w,4,d),
      new THREE.MeshStandardMaterial({color:0x37485a}));
    m.position.set(x,2,z); m.rotation.y = rot; m.castShadow = true; m.receiveShadow = true;
    walls.add(m);
  }
  for(let i=0;i<64;i++){
    const t=i/64*Math.PI*2, R1=120,R2=70;
    const x1=Math.cos(t)*R1, z1=Math.sin(t)*R1;
    const x2=Math.cos(t)*R2, z2=Math.sin(t)*R2;
    const seg=2.8, ang=Math.atan2(Math.sin(t),Math.cos(t));
    addWall(x1,z1,seg,6,ang); addWall(x2,z2,seg,6,ang);
  }
  scene.add(walls);

  car = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(4,1,6),
    new THREE.MeshStandardMaterial({color:0x40d2a8, metalness:.1, roughness:.7}));
  body.position.y=1.2; body.castShadow=true; car.add(body);
  function wheel(x,z){
    const w = new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,0.6,20),
      new THREE.MeshStandardMaterial({color:0x222}));
    w.rotation.z=Math.PI/2; w.position.set(x,0.6,z); w.castShadow=true; return w;
  }
  car.add(wheel( 1.6, 2.1)); car.add(wheel(-1.6, 2.1));
  car.add(wheel( 1.6,-2.1)); car.add(wheel(-1.6,-2.1));
  scene.add(car);
  car.position.set(0,0.6,-105);

  camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0,5,-10);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  const orbit = new OrbitControls(camera, renderer.domElement);
  orbit.enabled=false;

  // HUD
  const vEl = document.getElementById('v');
  const lapEl = document.getElementById('lap');
  const lapTimeEl = document.getElementById('lapTime');
  const bestEl = document.getElementById('best');
  let laps=0, lapStart=performance.now()/1000, best=null, crossed=false;

  function handleInput(dt){
    const accel = (keys['KeyW']||keys['ArrowUp'] ? 1:0) + (keys['KeyS']||keys['ArrowDown'] ? -1:0);
    const turn  = (keys['KeyA']||keys['ArrowLeft'] ? 1:0) + (keys['KeyD']||keys['ArrowRight'] ? -1:0);
    const handbrake = !!keys['Space'];

    // 动力/阻力
    if(accel>0) vel += 18*dt*accel; else if(accel<0) vel += 28*dt*accel;
    vel *= (handbrake? 0.985: 0.994); vel = Math.max(Math.min(vel,42), -12);

    const steerFactor = Math.max(0.2, 1.0 - Math.abs(vel)/50);
    steer += (-turn) * 1.3 * steerFactor * dt; car.rotation.y = steer;

    sideVel += (-turn) * Math.abs(vel)*0.06 * (handbrake? 1.8:0.8) * dt;
    sideVel *= (handbrake? 0.92 : 0.94);

    const forward = new THREE.Vector3(Math.sin(steer),0, Math.cos(steer));
    const right   = new THREE.Vector3(Math.cos(steer),0,-Math.sin(steer));
    const move = new THREE.Vector3().addScaledVector(forward, vel*dt).addScaledVector(right, sideVel*dt);
    car.position.add(move);

    // 碰墙
    const carBox = new THREE.Box3().setFromObject(car).expandByScalar(-1.6);
    for(const w of walls.children){
      const box = new THREE.Box3().setFromObject(w);
      if(box.intersectsBox(carBox)){
        const normal = new THREE.Vector3().subVectors(car.position, w.position).setY(0).normalize();
        car.position.addScaledVector(normal, 0.6);
        vel *= 0.5; sideVel *= -0.3; break;
      }
    }

    // 计圈
    const dist = car.position.distanceTo(new THREE.Vector3(0,0.6,-95));
    if(dist<6 && vel>6 && !crossed){
      crossed = true;
      const now = performance.now()/1000;
      const lapTime = now - lapStart; lapStart = now;
      laps++; lapEl.textContent = laps; lapTimeEl.textContent = lapTime.toFixed(2);
      if(!best || lapTime<best){ best=lapTime; bestEl.textContent = best.toFixed(2); }
    }
    if(dist>=8) crossed=false;

    vEl.textContent = Math.max(0, vel).toFixed(1);
  }

  const camTarget = new THREE.Vector3();
  function updateCamera(dt){
    const behind = new THREE.Vector3(Math.sin(steer),0, Math.cos(steer)).multiplyScalar(-10);
    behind.y = 4.5;
    camTarget.copy(car.position).add(behind);
    camera.position.lerp(camTarget, 1 - Math.pow(0.001, dt));
    camera.lookAt(car.position.x, car.position.y+1.2, car.position.z);
  }

  let last = performance.now()/1000;
  function tick(){
    const now = performance.now()/1000; let dt = now-last; last=now; if(dt>0.05) dt=0.05;
    if(!paused){ handleInput(dt); updateCamera(dt); }
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }
  tick();

  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // 小角标：当前使用的 CDN
  const tag = document.createElement('div');
  tag.style.cssText='position:fixed;right:12px;bottom:12px;font:12px/1 system-ui;color:#9bd6ff;opacity:.7';
  tag.textContent='CDN: ' + usedCdn.replace(/^https:\/\/(www\.)?/,'');
  document.body.appendChild(tag);
}

try{
  const { THREE: T, OrbitControls: OC, used } = await loadThree();
  THREE = T; OrbitControls = OC;
  setup(used);
}catch(e){
  console.error(e);
  showError(String(e.message || e));
}
</script>
</body>
</html>
